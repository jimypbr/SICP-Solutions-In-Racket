#lang racket
(require sicp)

;; Exercise 3.23 - deque
;; This needs to be implemented with a doubly linked list because we need
;; O(1) rear deletion.

;; doubly-linked node type that looks like: (val (front-ptr rear-ptr))
(define (make-node val)
  (cons val (cons '() '())))

(define (node-val node)
  (car node))

(define (node-next node)
  (cadr node))

(define (node-prev node)
  (cddr node))

(define (set-node-next! node item)
  (set-car! (cdr node) item))

(define (set-node-prev! node item)
  (set-cdr! (cdr node) item))


;; deque type that uses node type internally

(define (make-deque)
  (cons '() '()))

(define (front-ptr dq)
  (car dq))

(define (rear-ptr dq)
  (cdr dq))

(define (set-front-ptr! dq node)
  (set-car! dq node))

(define (set-rear-ptr! dq node)
  (set-cdr! dq node))

(define (empty-deque? dq)
  (null? (front-ptr dq)))

(define (front-deque dq)
  (if (empty-deque? dq)
      (error "Called FRONT-DEQUE on an empty DEQUE" dq)
      (node-val (front-ptr dq))))

(define (rear-deque dq)
  (if (empty-deque? dq)
      (error "Called REAR-DEQUE on an empty DEQUE" dq)
      (node-val (rear-ptr dq))))

(define (insert-front-deque! dq item)
  (let ((new-node (make-node item)))
    (if (empty-deque? dq)
        (begin (set-front-ptr! dq new-node)
               (set-rear-ptr! dq new-node)
               dq)
        (begin (set-node-next! new-node (front-ptr dq))
               (set-front-ptr! dq new-node)
               dq))))

(define (insert-rear-deque! dq item)
  (let ((new-node (make-node item)))
    (if (empty-deque? dq)
        (begin (set-rear-ptr! dq new-node)
               (set-front-ptr! dq new-node)
               dq)
        (begin (set-node-next! (rear-ptr dq) new-node)
               (set-node-prev! new-node (rear-ptr dq))
               (set-rear-ptr! dq new-node)
               dq))))

(define (delete-front-deque! dq)
  (if (empty-deque? dq)
      (error "Called DELETE-FRONT-DEQUE! on an empty deque!" dq)
      (if (null? (node-next (front-ptr dq)))
          (begin (set-front-ptr! dq null)
                 (set-rear-ptr! dq null)
                 dq)
          (begin (set-node-prev! (node-next (front-ptr dq)) null)
                 (set-front-ptr! dq (node-next (front-ptr dq)))
                 dq))))

(define (delete-rear-deque! dq)
  (if (empty-deque? dq)
      (error "Called DELETE-REAR-DEQUE! on an empty deque!" dq)
      (if (null? (node-prev (rear-ptr dq)))
          (begin (set-front-ptr! dq null)
                 (set-rear-ptr! dq null)
                 dq)
          (begin (set-node-next! (node-prev (rear-ptr dq)) null)
                 (set-rear-ptr! dq (node-prev (rear-ptr dq)))
                 dq))))


(module+ test
  (require rackunit)
  (let ((n (make-node 2))
        (m (make-node 5)))
    (check-equal? (node-val n) 2)
    (set-node-next! n m)
    (check-equal? (node-next n) m))
  (let ((n (make-node 2))
        (m (make-node 5)))
    (set-node-prev! n m)
    (check-equal? (node-prev n) m))
  (let ((n (make-node 2))
        (m (make-node 5))
        (l (make-node 7)))
    (set-node-next! n m)
    (set-node-prev! n l)
    (check-equal? (node-prev n) l)
    (check-equal? (node-next n) m))
  (let ((n (make-node 2))
        (m (make-node 5))
        (l (make-node 7)))
    (set-node-next! n m)
    (set-node-next! n '())
    (set-node-next! n m)
    (check-equal? (node-next n) m))
  (let ((d (make-deque)))
    (insert-front-deque! d 2)
    (check-equal? (front-deque d) 2)
    (check-equal? (rear-deque d) 2)
    (insert-front-deque! d 4)
    (check-equal? (front-deque d) 4)
    (check-equal? (rear-deque d) 2))
  (let ((d (make-deque)))
    (insert-rear-deque! d 2)
    (check-equal? (rear-deque d) 2)
    (check-equal? (front-deque d) 2)
    (insert-rear-deque! d 4)
    (check-equal? (rear-deque d) 4)
    (check-equal? (front-deque d) 2))
  (let ((d (make-deque)))
    (insert-front-deque! d 2)
    (insert-rear-deque! d 4)
    (check-equal? (rear-deque d) 4)
    (check-equal? (front-deque d) 2))
  (let ((d (make-deque)))
    (insert-front-deque! d 2)
    (insert-front-deque! d 4)
    (delete-front-deque! d)
    (check-equal? (front-deque d) 2))
  (let ((d (make-deque)))
    (insert-rear-deque! d 2)
    (insert-rear-deque! d 4)
    (delete-rear-deque! d)
    (check-equal? (rear-deque d) 2))
  (let ((d (make-deque)))
    (insert-front-deque! d 2)
    (insert-rear-deque! d 4)
    (insert-front-deque! d 5)
    (delete-front-deque! d)
    (check-equal? (front-deque d) 2)
    (delete-rear-deque! d)
    (check-equal? (rear-deque d) 2)
    (delete-front-deque! d)
    (check-equal? d (make-deque))))
  
 
